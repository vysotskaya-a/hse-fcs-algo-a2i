# Исследование производительности алгоритмов Merge Sort и Merge+Insertion Sort
### Высоцкая Анна - посылка Codeforces: 348255805

##  Цель
Провести эмпирическое сравнение:
- стандартного рекурсивного **Merge Sort**;
- гибридного **Merge + Insertion Sort**, который при малых подмассивах (до `threshold`) использует вставки.

Анализ выполнялся для трёх типов массивов:
1. **Случайные значения** (0–6000)
2. **Отсортированные по убыванию**
3. **Почти отсортированные** (несколько случайных перестановок в уже отсортированном массиве)

Размеры массивов: от **500** до **100 000** с шагом **100**.  
Для всех экспериментов генерировался один базовый массив длиной 100 000, из которого брались префиксы нужной длины.

---

## Структура проекта
```
a2i/
├── src/
│ ├── ArrayGenerator.h
│ ├── SortTester.h
│ ├── sort_algorithms.h
│ └── main.cpp
├── plot.py
├── results/
│ ├── raw_results.csv
│ ├── summary.csv
│ └── plots/
└── README.md
```

## Запуск эксперимента

### 1. Скомпилировать C++ программу
```bash
g++ -std=c++17 -Wall -Wextra -Iinclude -o app main.cpp
./app
```
После завершения появятся файлы:
results/raw_results.csv
results/summary.csv
```bash
pip install pandas matplotlib
python3 plot.py
```
Все PNG-файлы появятся в results/plots/.

## Результаты экспериментов и интерпретация

### 1. random_merge_std.png
**Описание:**  
График времени выполнения стандартного алгоритма Merge Sort на случайных массивах (элементы равномерно распределены от 0 до 6000).  

**Интерпретация:**  
Линейно-логарифмическая зависимость видна хорошо — рост времени близок к `O(n log n)`.  
Шум — это погрешность измерений и особенности выделения памяти.

---

### 2. random_merge_hybrid.png
**Описание:**  
Время выполнения гибридного Merge + Insertion Sort для разных порогов `THRESHOLD`.  

**Интерпретация:**  
Каждая кривая соответствует своему порогу (например, 5, 10, 20, 30, 50).  
Для малых `THRESHOLD` время растёт быстрее из-за частых рекурсий,  
для больших — медленнее на малых `n`, но хуже на больших.

---

### 3. random_comparison.png !!!
**Описание:**  
Сравнение стандартного и гибридного Merge Sort на случайных массивах.  

**Интерпретация:**  
Гибридный алгоритм стабильно быстрее при небольших `n` (до ~30 000–50 000 элементов).  
На больших размерах массивов обе реализации дают схожие результаты.

---

### 4. reverse_merge_std.png
**Описание:**  
Стандартный Merge Sort на массивах, отсортированных в обратном порядке (наихудший случай для многих алгоритмов).  

**Интерпретация:**  
Кривая почти идентична случайной — Merge Sort не чувствителен к степени упорядоченности,  
что подтверждает его устойчивость по времени.

---

### 5. reverse_merge_hybrid.png
**Описание:**  
Гибридный Merge + Insertion Sort на обратных массивах.  

**Интерпретация:**  
Insertion Sort внутри гибрида работает хуже на обратных массивах,  
поэтому прирост производительности по сравнению со стандартным Merge Sort минимальный.  

---

### 6. reverse_comparison.png !!!
**Описание:**  
Сравнение стандартного и гибридного Merge Sort для обратных массивов.  

**Интерпретация:**  
Гибридный алгоритм показывает преимущество только при небольших `n`,  
а при росте длины массива преимущество исчезает.

---

### 7. almost_merge_std.png
**Описание:**  
Стандартный Merge Sort на почти отсортированных массивах.  

**Интерпретация:**  
Кривая немного ниже, чем на случайных массивах,  
так как Merge Sort частично использует существующий порядок (меньше обменов при слиянии).

---

### 8. almost_merge_hybrid.png
**Описание:**  
Гибридный Merge + Insertion Sort на почти отсортированных массивах.  

**Интерпретация:**  
Insertion Sort показывает отличные результаты,  
поэтому гибридный алгоритм здесь выигрывает особенно заметно.  
Оптимальный `THRESHOLD` — около **20**.

---

### 9. almost_comparison.png !!!
**Описание:**  
Сравнение стандартного и гибридного Merge Sort на почти отсортированных массивах.  

**Интерпретация:**  
Insertion Sort на почти отсортированных кусках работает почти линейно O(k), что 
даёт огромный выигрыш. При росте массива количество «малых» кусков уменьшается,
но эффект всё ещё заметен.

# Итоговые выводы

1. **Гибридный Merge Sort** всегда выигрывает на **малых и средних размерах** массива (до ~40–60 k элементов) **независимо от структуры данных**.

2. На **почти отсортированных данных** гибрид даёт **наибольший выигрыш** (до **2–3× ускорения**) благодаря почти линейной работе **Insertion Sort**.

3. На **полностью случайных и обратных массивах** преимущество ограничено только малыми `n`; при `n ≥ 80 000` обе реализации **практически идентичны**.

4. **Практическая рекомендация:**
   - Использовать гибрид с порогом `threshold ≈ 16–64`.  
   - Особенно оправдано для данных, которые **часто бывают частично упорядоченными**.  
   - Для **строго случайных больших массивов** выигрыш минимален — можно оставить чистый **Merge Sort** ради простоты кода.

> **Таким образом, Best Hybrid — это «универсальный» вариант, который никогда не хуже стандартного и даёт ощутимый прирост в большинстве реальных сценариев.**
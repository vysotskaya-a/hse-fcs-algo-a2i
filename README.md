# Исследование производительности алгоритмов Merge Sort и Merge+Insertion Sort
### Высоцкая Анна - посылка Codeforces: 348255805

##  Цель
Провести эмпирическое сравнение:
- стандартного рекурсивного **Merge Sort**;
- гибридного **Merge + Insertion Sort**, который при малых подмассивах (до `threshold`) использует вставки.

Анализ выполнялся для трёх типов массивов:
1. **Случайные значения** (0–6000)
2. **Отсортированные по убыванию**
3. **Почти отсортированные** (несколько случайных перестановок в уже отсортированном массиве)

Размеры массивов: от **500** до **100 000** с шагом **100**.  
Для всех экспериментов генерировался один базовый массив длиной 100 000, из которого брались префиксы нужной длины.

---

## Структура проекта
```
a2i
├── src
│   ├── ArrayGenerator.h
│   ├── main.cpp
│   ├── results.csv
│   ├── run_experiments
│   └── SortTester.h
├── plot_almost_sorted.png
├── plot_random.png
├── plot_reverse_sorted.png
├── plots.py
└── README.md
```

## Запуск эксперимента

### 1. Скомпилировать C++ программу
```bash
g++ -std=c++17 -Wall -Wextra -Iinclude -o app main.cpp
./app
```
После завершения появятся файлы:
src/results.csv
```bash
pip install pandas matplotlib
python plots.py src/results.csv
```
Все PNG-файлы появятся в a2i/.

## Результаты экспериментов и интерпретация

## Введение

## Результаты (графики)

### 1. Тип массива: `random`

- **Standard**: O(n log n), но с **высокой волатильностью** (пики до 25 мс).
- **Hybrid_5**: хуже standard — слишком частые переключения.
- **Hybrid_10–20**: умеренное улучшение.
- **Hybrid_30–50**: *лучшие, особенно **hybrid_50** — самая гладкая кривая.

**Выигрыш hybrid_50**: до **2 раз** при n = 100000.

---

### 2. Тип массива: `almost_sorted`

- **Standard**: меньше пиков, чем в random.
- **Hybrid_5**: **хуже всех** — переключения не окупаются.
- **Hybrid_30–50**: **значительно быстрее**, особенно **hybrid_50** — почти линейный рост.

**Выигрыш hybrid_50**: до **2.5 раз** при больших n.

---

### 3. Тип массива: `reverse_sorted`

- **Standard**: глубокие пики (до 17 мс).
- **Hybrid_5–10**: **прям медленно** — Insertion Sort на малых блоках делает O(k²).
- **Hybrid_30–50**: **стабильно лучше**, **hybrid_30** — оптимально.

**Выигрыш hybrid_30**: до **1.8×**.

---


## Общие выводы

1. **Гибридный подход превосходит стандартный** при правильном выборе порога.
2. **Оптимальный порог: 40–50 элементов**.
3. **Выигрыш начинается с n ≈ 20 000**, максимален при **n = 100 000**.
4. **Гибрид устойчивее** — меньше пиков, предсказуемое поведение.
5. **Наибольший эффект** на `almost_sorted` и `reverse_sorted` — Insertion Sort эффективен локально.
6. **Пороги ≤10 не окупаются** из-за накладных расходов.

> **Рекомендация**:  
> **Использовать гибридный Merge Sort с `threshold = 45`**.  
> Это даёт **максимальную производительность, стабильность и универсальность**.
